from dash import Dash, dcc, html, Input, Output
import plotly.express as px
import pandas as pd
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
import dash_bootstrap_components as dbc
from dash_bootstrap_templates import ThemeSwitchAIO
import psycopg2
import joblib
import datetime
from sklearn.ensemble import RandomForestRegressor

# Conexão com o banco de dados
DATABASE_URI = 'postgresql+psycopg2://postgres:123@localhost/projeto isaac'

engine = create_engine(DATABASE_URI)
Session = sessionmaker(bind=engine)

def get_data_from_postgres():
    session = Session()
    
    query = "WITH LatestCars AS (SELECT vin, brandname, modelname, msrp, askprice, vf_baseprice, firstseen, lastseen, vf_modelyear, ROW_NUMBER() OVER (PARTITION BY modelname ORDER BY lastseen DESC) AS row_num FROM cars) SELECT * FROM LatestCars WHERE row_num = 1 ORDER BY askprice DESC LIMIT 30;"
    df_bar = pd.read_sql(query, session.bind)
    
    session.close()
    
    return df_bar

df_bar = get_data_from_postgres()

def get_data_from_postgres_pizza():
    session = Session()
    
    query = "SELECT vin, modelname, askprice, brandname FROM cars WHERE askprice IS NOT NULL ORDER BY askprice DESC LIMIT 20"
    df_pizza = pd.read_sql(query, session.bind)
    
    session.close()
    
    return df_pizza

df_pizza = get_data_from_postgres_pizza()

def get_data_from_postgres_scatter():
    session = Session()
    
    query = "WITH MarcaTotalPreco AS (SELECT brandname, SUM(askprice) AS total_preco FROM cars GROUP BY brandname ORDER BY total_preco DESC LIMIT 20), LatestCars AS (SELECT vin, brandname, modelname, msrp, askprice, vf_baseprice, firstseen, lastseen, vf_modelyear, ROW_NUMBER() OVER (PARTITION BY modelname ORDER BY lastseen DESC) AS row_num FROM cars), RankedCars AS (SELECT *, RANK() OVER (PARTITION BY brandname ORDER BY askprice DESC) AS rank FROM LatestCars WHERE row_num = 1 AND brandname IN (SELECT brandname FROM MarcaTotalPreco)) SELECT * FROM RankedCars WHERE rank <= 15 ORDER BY brandname, askprice DESC;"
    df_scatter = pd.read_sql(query, session.bind)
    
    session.close()
    
    return df_scatter

df_scatter = get_data_from_postgres_scatter()

# Carregar o modelo de ML
modelo = joblib.load('modelo_previsao_veiculos.joblib')

import joblib
import pandas as pd

# Carregar o modelo de ML
modelo = joblib.load('modelo_previsao_veiculos.joblib')

#import joblib
import pandas as pd
import datetime
from sklearn.ensemble import RandomForestRegressor

# Carregar o modelo de ML
modelo = joblib.load('modelo_previsao_veiculos.joblib')

# Carregar as colunas que foram utilizadas durante o treinamento
colunas_modelo = joblib.load('colunas_treinamento.pkl')  # Carregar as colunas usadas no treinamento

def transformar_dados(df):
    # Garantir que a coluna 'vf_modelyear' seja numérica
    if isinstance(df['vf_modelyear'].iloc[0], (pd.Timestamp, datetime.date)):
        df['ano'] = pd.to_datetime(df['vf_modelyear']).dt.year
    else:
        df['ano'] = df['vf_modelyear'].astype(int)  # Se já for numérico, converte para inteiro

    # Codificar a coluna 'marca' com pd.get_dummies()
    df_dummies = pd.get_dummies(df[['brandname', 'ano']], drop_first=True)
    
    # Garantir que as colunas do modelo sejam consistentes
    # Adicionar as colunas faltantes com 0
    df_dummies = df_dummies.reindex(columns=colunas_modelo, fill_value=0)
    
    return df_dummies

# Exemplo de aplicação da transformação para as previsões
df_transformed = transformar_dados(df_scatter)

# Realizar a previsão com as variáveis transformadas
df_scatter['preco_previsto'] = modelo.predict(df_transformed)

app = Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

# Configuração de temas
url_theme1 = dbc.themes.MORPH
url_theme2 = dbc.themes.SOLAR
template_theme1 = 'morph'
template_theme2 = 'solar'

# Opções de marcas
opcoes = list(df_pizza['brandname'].unique())
opcoes.append("Todos os Carros")

# Gerando dicionário de marcas para usar no Slider
brand_options = {i: brand for i, brand in enumerate(df_scatter['brandname'].unique())}

# Layout do app
app.layout = dbc.Container([
    dbc.Row([
        dbc.Col([
            ThemeSwitchAIO(aio_id='theme', themes=[url_theme1, url_theme2]),
            html.H1(children='Previsão de Preço de Carros', style={'textAlign': 'center'}), 
            html.H3(children='Uma dashboard feita por Douglas Gobitsch, Cauã Guerreiro e Vinícius Raiol.',
                    style={'textAlign': 'center'})
        ])
    ]),

    # Dropdown para selecionar a marca
    dbc.Row([
        dbc.Col([
            dcc.Dropdown(opcoes, value='Todos os Carros', id='brand-dropdown', placeholder="Selecione a marca"),
        ])
    ]),

    # Opções para selecionar o tipo de gráfico
    dbc.Row([
        dbc.Col([
            dcc.RadioItems(
                id='chart-type',
                options=[
                    {'label': 'Gráfico de Dispersão', 'value': 'scatter'},
                    {'label': 'Gráfico de Colunas', 'value': 'bar'},
                    {'label': 'Gráfico de Pizza', 'value': 'pie'}  # Nova opção de gráfico de pizza
                ],
                value='scatter',  # Valor padrão
                labelStyle={'display': 'inline-block', 'margin-right': '10px'}
            )
        ])
    ]),

    # Slider para selecionar marcas (visível apenas no gráfico de dispersão)
    dbc.Row([
        dbc.Col([
            dcc.Slider(
                id='brand-slider',
                min=0,
                max=len(brand_options) - 1,
                value=0,  # Valor inicial
                marks=brand_options,  # Mapeia o índice para as marcas
                step=None,  # Passo fixo por marca
                tooltip={"placement": "bottom", "always_visible": True}
            )
        ], id='slider-container')  # Este contêiner será controlado pela callback para aparecer/desaparecer
    ]),

    # Gráfico
    dbc.Row([
        dbc.Col([
            dcc.Graph(id='example-graph')
        ])
    ])
    
])

# Função de callback para atualizar o gráfico com base nas seleções do usuário
@app.callback(
    Output('example-graph', 'figure'),
    Output('slider-container', 'style'),  # Controla a visibilidade do slider
    Input('brand-dropdown', 'value'),
    Input('brand-slider', 'value'),
    Input('chart-type', 'value'),
    Input(ThemeSwitchAIO.ids.switch('theme'), 'value')
)
def update_graph(selected_brand, selected_slider_brand, chart_type, toggle):
    templates = template_theme1 if toggle else template_theme2

    # Filtrar dados com base na marca selecionada
    if selected_brand == "Todos os Carros":
        tabela_filtrada_bar = df_bar
        tabela_filtrada_pizza = df_pizza
        tabela_filtrada_scatter = df_scatter
    else:
        tabela_filtrada_bar = df_bar[df_bar['brandname'] == selected_brand]
        tabela_filtrada_pizza = df_pizza[df_pizza['brandname'] == selected_brand]
        tabela_filtrada_scatter = df_scatter[df_scatter['brandname'] == selected_brand]

    # Realizar previsão de preço para o gráfico de dispersão
    if chart_type == 'scatter':
        selected_brand_name = brand_options[selected_slider_brand]  # Pega o nome da marca selecionada no slider
        tabela_filtrada_scatter = tabela_filtrada_scatter[tabela_filtrada_scatter['brandname'] == selected_brand_name]

        # Obter as previsões do modelo de ML
        tabela_filtrada_scatter['preco_previsto'] = modelo.predict(tabela_filtrada_scatter[['vf_modelyear', 'brandname']])

        # Gerar o gráfico de dispersão
        fig = px.scatter(tabela_filtrada_scatter, x="modelname", y="preco_previsto", color="brandname", template=templates)
        slider_style = {'display': 'block'}  # Mostra o controle deslizante

    # Se o tipo de gráfico for 'bar', exibe o gráfico de barras
    elif chart_type == 'bar':
        tabela_filtrada_bar['preco_previsto'] = modelo.predict(tabela_filtrada_bar[['vf_modelyear', 'brandname']])
        fig = px.bar(tabela_filtrada_bar, x="modelname", y="preco_previsto", color="brandname", template=templates)
        slider_style = {'display': 'none'}  # Esconde o controle deslizante

    # Se o tipo de gráfico for 'pie', cria um gráfico de pizza com base nas previsões
    elif chart_type == 'pie':
        tabela_filtrada_pizza['preco_previsto'] = modelo.predict(tabela_filtrada_pizza[['vf_modelyear', 'brandname']])
        fig = px.pie(tabela_filtrada_pizza, names='brandname', values='preco_previsto', template=templates)
        slider_style = {'display': 'none'}  # Esconde o controle deslizante

    fig.update_layout(template=templates)
    
    return fig, slider_style


if __name__ == '__main__':
    app.run(debug=True)
